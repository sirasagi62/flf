[{"buffername": "src/index.ts", "content": "#!/usr/bin/env node\n\n// Supress warining on iTerm\nimport os from \"node:os\";\nif (os.type() === \"Darwin\" && process.env.TERM?.includes(\"xterm\"))\n  process.env.TERM = \"iTerm.app\"\n\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers'\n\nimport blessed from 'blessed';\nimport { highlight } from 'cli-highlight';\nimport { Point } from \"code-chopper\";\nimport fs from \"node:fs\"\nimport tty from \"node:tty\"\nimport { FlfDirCore } from \"./dircore.js\";\nimport { IFlfCore, ListItem, OutputType } from \"./types.js\";\nimport { FlfBufferCore } from \"./buffercore.js\";\n\n\ninterface UIOptions {\n  editor: OutputType\n}\nconst setupTTY = () => {\n  if (process.versions.bun && os.type() === \"Darwin\") {\n    console.log(`Due to a bug in Bun on macOS, the pipe functionality is not available in Bun.\nSee here for details: https://github.com/oven-sh/bun/issues/24158`)\n    return { input: process.stdin, output: process.stdout };\n  } else {\n\n    const ttyIn = new tty.ReadStream(fs.openSync(\"/dev/tty\", \"r\"));\n    const ttyOut = new tty.WriteStream(fs.openSync(\"/dev/tty\", \"w\"));\n    ttyIn.resume();\n    ttyIn.setRawMode(true);\n    return {\n      input: ttyIn,\n      output: ttyOut\n    }\n  }\n}\n\nconst { input: ttyIn, output: ttyOut } = setupTTY()\nconst DEBUG = false\nconst LOGO = `\n\n ███████╗ ██╗      ███████╗\n ██╔════╝ ██║      ██╔════╝\n █████╗   ██║      █████╗\n ██╔══╝   ██║      ██╔══╝\n ██║      ███████╗ ██║\n ╚═╝      ╚══════╝ ╚═╝\n`\n// 検索対象のリスト\ninterface UnicodeKey {\n  ch: string,\n  full: string,\n  name: null\n}\ninterface AsciiKey {\n  sequence: string,\n  ctrl: boolean,\n  shift: boolean,\n  meta: boolean,\n  name: string,\n  full: string\n}\ntype KeyInput = UnicodeKey | AsciiKey\n\n\n/**\n * Blessed を使用したターミナルベースのファジーファインダーを実装するクラス。\n */\nexport class FluentFinderUI {\n  private core: IFlfCore;\n  private screen: blessed.Widgets.Screen;\n  private input: blessed.Widgets.TextboxElement;\n  private list: blessed.Widgets.ListElement;\n  private preview: blessed.Widgets.BoxElement;\n\n  private currentResult: ListItem[] = []\n  private options\n\n\n  constructor(core: IFlfCore, options: UIOptions) {\n    this.screen = this.createScreen();\n    this.input = this.createInput();\n    this.list = this.createList();\n    this.preview = this.createPreview();\n    this.core = core\n\n    this.setupLayout();\n    this.bindKeys();\n    this.bindInputEvents();\n\n    // 初期表示\n    this.updateList([]);\n    this.options = options\n    this.updatePreviewWithTitle(LOGO)\n    this.input.focus();\n    this.screen.render();\n  }\n\n\n  private createScreen(): blessed.Widgets.Screen {\n    const program = blessed.program({\n      //@ts-ignore\n      input: ttyIn,\n\n      //@ts-ignore\n      output: ttyOut\n    })\n    return blessed.screen({\n      program: program,\n      smartCSR: true,\n      title: 'Blessed Fuzzy Finder',\n      fullUnicode: true,\n    });\n  }\n\n  private createInput(): blessed.Widgets.TextboxElement {\n    return blessed.textbox({\n      parent: this.screen,\n      top: 0,\n      left: 0,\n      height: 1,\n      width: '100%',\n      style: {\n        bg: 'black',\n        fg: 'white'\n      },\n      content: '',\n    });\n  }\n\n  private createList(): blessed.Widgets.ListElement {\n    return blessed.list({\n      parent: this.screen,\n      top: 1,\n      left: 0,\n      height: '100%-1',\n      width: '50%',\n      keys: true,\n      vi: true,\n      style: {\n        selected: {\n          bold: true,\n          inverse: true,\n          fg: \"red\"\n        },\n      },\n      items: [], // 初期表示\n    });\n  }\n\n  private createPreview(): blessed.Widgets.BoxElement {\n    const box = blessed.box({\n      parent: this.screen,\n      top: 1,\n      left: '50%',\n      height: '100%-1',\n      width: '50%',\n      border: {\n        type: 'line'\n      },\n      keys: false,\n      vi: false,\n      style: {\n        border: {\n          fg: 'white'\n        }\n      },\n    });\n    box.content = highlight(\"\", { language: '', ignoreIllegals: true });\n    return box;\n  }\n\n  private setupLayout(): void {\n    this.screen.append(this.input);\n    this.screen.append(this.list);\n    this.screen.append(this.preview);\n  }\n\n  /**\n   * プレビューの内容を更新します。\n   * @param title プレビューに含めるタイトル文字列\n   */\n  private updatePreviewWithTitle(content: string, language?: string): void {\n    this.preview.content = highlight(content, {\n      language: language ?? \"\",\n      ignoreIllegals: true\n    });\n    this.screen.render();\n  }\n\n  /**\n   * 現在選択されているリストアイテムに基づいてプレビューを更新します。\n   */\n  private updatePreview(): void {\n    // @ts-ignore\n    const idx = this.list.selected;\n    const selectedItem = this.currentResult[idx]\n    if (!selectedItem) throw Error(\"selectedItem is undefined\")\n    this.updatePreviewWithTitle(selectedItem.content, selectedItem.language);\n  }\n\n  /**\n   * リストの内容をフィルタリングされたアイテムで更新します。\n   * @param items 表示するアイテムの配列\n   */\n  public updateList(items: ListItem[]): void {\n    this.currentResult = items\n    this.list.clearItems()\n    this.list.setItems(items.map(i => this.convertListItemToListTitle(i)));\n\n    // リストのカーソルをリセット\n    if (items.length > 0) {\n      this.list.select(0);\n    }\n\n    // プレビューの初期更新\n    const item = items.at(0);\n    this.updatePreviewWithTitle(item?.content ?? \"\", item?.language ?? \"\")\n  }\n\n  /**\n   * 検索クエリが変更されたときの処理を行います。\n   * **`blessed.textbox` の `change` イベントを使用することで、値が更新された後に検索を実行できます。**\n   */\n  private async handleQueryChange(key: KeyInput): Promise<void> {\n    let query = this.input.value.trim();\n    if (key.name) {\n      if (key.name === 'backspace') {\n        query = [...query].slice(0, -1).join('')\n      } else if (key.name === 'enter') {\n        try {\n          if (this.currentResult.length === 0) {\n            this.screen.destroy()\n            this.destroyTTY()\n          }\n          // @ts-ignore\n          const listIdx: number = this.list.selected;\n          const selectedItem = this.currentResult.at(listIdx)\n\n          if (selectedItem) {\n            this.screen.destroy();\n            this.showResult(selectedItem, this.options.editor)\n            this.destroyTTY()\n          }\n        } finally {\n\n        }\n      } else if (key.name === 'up') {\n        this.list.up(1);\n        this.updatePreview();\n        return;\n      } else if (key.name === 'down') {\n        this.list.down(1);\n        this.updatePreview();\n        return;\n      } else if (!(key.ctrl || key.meta || key.shift) && key.name.length === 1) {\n        query += key.name\n      } else if (key.ctrl && key.name === \"c\") {\n        this.screen.destroy()\n        this.destroyTTY()\n      }\n    } else {\n      query += key.full\n    }\n\n\n    const res = await this.core.search({\n      queryText: query,\n      isJsonOutput: true,\n      k: 20,\n      dbPath: \":memory:\"\n    })\n\n    // リストを更新\n    this.updateList(\n      res\n        .sort((a, b) => a.rank - b.rank)\n        .map(r => {\n          return {\n            filePath: r.file,\n            entity: r.entity,\n            content: r.contentSnippet,\n            language: r.language,\n            cursorInfo: r.cursorInfo,\n          }\n        }));\n    //}\n    this.screen.render();\n  }\n\n  /**\n   * UI要素と関連するキーバインドを設定します。\n   */\n  private bindKeys(): void {\n    // プログラム終了処理\n    this.screen.key(['escape', 'q', 'C-c'], () => {\n      //return process.exit(0);\n      this.screen.destroy()\n      this.destroyTTY()\n    });\n\n  }\n\n  /**\n   * 入力ボックスのイベントを設定します。\n   */\n  private bindInputEvents(): void {\n    this.input.on('keypress', (_ch, key) => {\n      this.handleQueryChange(key);\n    });\n\n  }\n\n\n  /**\n   * アプリケーションを実行します。\n   */\n  public run(): void {\n    this.screen.render();\n    this.input.readInput(); // 入力待ちを開始\n  }\n\n  private destroyTTY() {\n    ttyIn.setRawMode(false);\n    ttyIn.pause();\n    ttyIn.destroy();\n    ttyOut.end();\n  }\n\n  private showResult(result: ListItem, outputType: OutputType = \"nvim\") {\n    const query = this.core.formatResult(result,outputType)\n    console.log(query)\n    if (DEBUG) {\n      ttyOut.write(query)\n      ttyOut.write(\"\\n\")\n    }\n  }\n  private convertListItemToListTitle(item: ListItem) {\n    return `${item.filePath}#${item.entity}`\n  }\n}\n\nconst dirSubCommand = async (path: string, editor: OutputType) => {\n  ttyOut.write(`Indexing...:${path}\\n`)\n\n  const core = await FlfDirCore.init(\":memory:\")\n  core.indexDirectory(path).then(async () => {\n    const initList = await core.search({\n      queryText: \" \",\n      isJsonOutput: true,\n      k: 20,\n      dbPath: \":memory:\"\n    })\n    const interactiveUI = new FluentFinderUI(core, {\n      editor\n    })\n    interactiveUI.updateList(initList\n      .sort((a, b) => a.rank - b.rank)\n      .map(r => {\n        return {\n          filePath: r.file,\n          entity: r.entity,\n          content: r.contentSnippet,\n          language: r.language,\n          cursorInfo: r.cursorInfo,\n        }\n      }))\n    interactiveUI.run()\n  })\n}\n\nconst bufSubCommand = async (path: string, editor: OutputType) => {\n  ttyOut.write(`Indexing Buffers...\\n`)\n\n  const core = await FlfBufferCore.init(\":memory:\")\n  core.index(path).then(async () => {\n    const initList = await core.search({\n      queryText: \" \",\n      isJsonOutput: true,\n      k: 20,\n      dbPath: \":memory:\"\n    })\n    const interactiveUI = new FluentFinderUI(core, {\n      editor\n    })\n    interactiveUI.updateList(initList\n      .sort((a, b) => a.rank - b.rank)\n      .map(r => {\n        return {\n          filePath: r.file,\n          entity: r.entity,\n          content: r.contentSnippet,\n          language: r.language,\n          cursorInfo: r.cursorInfo,\n        }\n      }))\n    interactiveUI.run()\n  })\n}\n\nyargs(hideBin(process.argv))\n  .command('dir', 'Perform fluent search on file paths (Directory search)', (yargs) => {\n    return yargs\n      .option('path', {\n        alias: 'p',\n        description: 'path to fluent search',\n        default: '.',\n        type: 'string'\n      })\n      .option('editor', {\n        alias: 'e',\n        description: 'Editor command to start up new buffer',\n        choices: ['nvim', 'vim', 'emacs', 'cmd'],\n        default: 'cmd',\n        type: 'string'\n      })\n  }, (argv) => {\n    dirSubCommand(argv.path, argv.editor as OutputType)\n  })\n\n  .command('buf', 'Perform fluent search on current editor buffers', (yargs) => {\n    return yargs\n      .option('path', {\n        alias: 'p',\n        description: 'path to fluent search',\n        default: '.',\n        type: 'string'\n      })\n      .option('editor', {\n        alias: 'e',\n        description: 'Editor command to start up new buffer',\n        choices: ['nvim', 'vim', 'emacs', 'cmd'],\n        default: 'cmd',\n        type: 'string'\n      })\n  }, (_) => {\n\n    console.log('buf command executed.')\n  })\n\n  .help()\n  .demandCommand(1, 'You need to specify at least one command.')\n  .strict()\n  .parseSync()\n"}]